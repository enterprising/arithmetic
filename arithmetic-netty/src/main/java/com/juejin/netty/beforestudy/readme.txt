# 原生io
IO编程模型在客户端较少的情况下运行良好，但是对于客户端比较多的业务来说，单机服务端可能需要支撑成千上万的连接，IO模型可能就不太合适了，我们来分析一下原因。
上面的demo，从服务端代码中我们可以看到，在传统的IO模型中，每个连接创建成功之后都需要一个线程来维护，每个线程包含一个while死循环，那么1w个连接对应1w个线程，继而1w个while死循环，这就带来如下几个问题：

线程资源受限：线程是操作系统中非常宝贵的资源，同一时刻有大量的线程处于阻塞状态是非常严重的资源浪费，操作系统耗不起
线程切换效率低下：单机cpu核数固定，线程爆炸之后操作系统频繁进行线程切换，应用性能急剧下降。
除了以上两个问题，IO编程中，我们看到数据读写是以字节流为单位，效率不高。

为了解决这三个问题，JDK在1.4之后提出了NIO。


# 关于jdk自带的nio
1、nio模型中一般会出现两个线程，每个线程绑定一个轮训器selector；在我们这个例子中serverSelector负责轮询是否有新的连接，clientSelector负责轮询连接是否有数据可读
2、服务端检测到新的连接后，不再创建新的线程，而是把这个连接绑定到选择器中；
3、clientSelector被一个 while 死循环包裹着，如果在某一时刻有多条连接有数据可读，那么通过 clientSelector.select(1)方法可以轮询出来，进而批量处理，参见(2)
4、数据的读写面向 Buffer，不再直接面向字节流，这样有了缓存之后会效率提升很多。

不建议使用Java原生nio的原因
1、要理解很多概念，编程模型不友好，ByteBuffer 的 Api 简直反人类
2、对 NIO 编程来说，一个比较合适的线程模型能充分发挥它的优势，而 JDK 没有给你实现，你需要自己实现，就连简单的自定义协议拆包都要你自己实现
3、JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%
4、复杂度上升，项目庞大后，会各种bug


# netty
Netty 封装了 JDK 的 NIO，让你用得更爽，你不用再写一大堆复杂的代码了。 用官方正式的话来说就是：Netty 是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端。

用netty，不用jdk nio的原因
1、使用简单，没有jdk nio那么复杂
2、netty 底层io模型可以随意切换，只要简单的参数调整，nio就能变成io，但是这个在jdk中是很难的
3、netty 自带拆解包的工具、异常检测等，让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑
4、Netty 解决了 JDK 的很多包括空轮询在内的 Bug
5、Netty 底层对线程，selector 做了很多细小的优化，精心设计的 reactor 线程模型做到非常高效的并发处理
6、支持多协议栈，几乎不用自己动手写协议，除非是要用户自定义协议；
7、社区活跃、大的rpc框架基本上基于这个


